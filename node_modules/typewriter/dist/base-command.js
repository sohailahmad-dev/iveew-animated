"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseCommand = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@oclif/core");
const debug_1 = require("debug");
const inquirer_1 = require("inquirer");
const tty_1 = tslib_1.__importDefault(require("tty"));
const api_1 = require("./api");
const ttys_1 = require("./common/ttys");
const config_1 = require("./config");
const languages_1 = require("./languages");
const telemetry_1 = require("./telemetry");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const ci_detect_1 = tslib_1.__importDefault(require("@npmcli/ci-detect"));
const DEFAULT_CONFIG_PATH = "./";
/**
 * Reads the stdin input
 * @returns string
 */
const readStdin = async () => {
    const { stdin } = process;
    let result;
    if (tty_1.default.isatty(0)) {
        return result;
    }
    result = "";
    stdin.setEncoding("utf8");
    for await (const chunk of stdin) {
        result += chunk;
    }
    return result;
};
/**
 * Base Command class.
 *
 * Handles loading the configuration and common flags, also adds support for pipes
 * All commands should extend this class!
 */
class BaseCommand extends core_1.Command {
    constructor(argv, config) {
        super(argv, config);
        /**
         * Show verbose debug messages
         */
        this.isDebugEnabled = false;
        /**
         * Path to the workspace config
         */
        this.configPath = DEFAULT_CONFIG_PATH;
        /**
         * A module of inquirer.js that is pipe friendly
         */
        this.prompt = (0, inquirer_1.createPromptModule)({
            input: ttys_1.ttys.stdin,
            output: ttys_1.ttys.stdout,
        });
        this.hasConfigUpdates = false;
        this.segmentClient = (0, telemetry_1.getSegmentClient)(config);
    }
    get apiToken() {
        return this.tokenMetadata?.token ?? undefined;
    }
    get workspace() {
        return this.tokenMetadata?.workspace;
    }
    get rawCommand() {
        return `${this.id} ${this.argv.join(" ")}`;
    }
    // Catch any error and report to segment
    async catch(err) {
        this.segmentClient.commandError({
            properties: {
                command: this.id,
                errorMessage: `Error: ${err.message}\n${err.stack}`,
                error: err,
                rawCommand: this.argv.join(" "),
                errorCode: err.exitCode,
                isCI: `${this.isCI}`,
            },
        });
        // We do a flush here manually cause oclif doesn't run the postrun hook for errors
        try {
            await this.segmentClient.closeAndFlush();
        }
        catch { }
        return super.catch(err);
    }
    async init() {
        await super.init();
        this.pipedInput = await readStdin();
        this.debug("Piped Input:", this.pipedInput);
        this.isCI = (0, ci_detect_1.default)();
        // Load common flags and arguments
        // We have to do this weird parse call cause of this bug in OCLIF when extending base commands with flags: https://github.com/oclif/oclif/issues/225
        const { flags } = await this.parse(this.constructor);
        this.configPath = flags.config;
        // We can enable debug either from the DEBUG environment variable or from the CLI flag.
        const isEnvDebugEnabled = debug_1.debug.enabled("typewriter");
        this.isDebugEnabled = flags.debug || isEnvDebugEnabled;
        if (!isEnvDebugEnabled && this.isDebugEnabled) {
            debug_1.debug.enable("*");
        }
        this.debug(`Debug enabled: ${this.isDebugEnabled}`);
        this.debug(`Config path: ${this.configPath}`);
        // Load user config if it exists.
        this.workspaceConfig = await (0, config_1.getWorkspaceConfig)(this.configPath);
        if (this.workspaceConfig === undefined) {
            this.debug(`No config found at ${this.configPath}`);
        }
        else {
            this.debug(`Workspace config: ${JSON.stringify(this.workspaceConfig)}`);
        }
        // Try to get the token for the user
        const tokenMetadata = await (0, config_1.getToken)(this.workspaceConfig, this.configPath, this.pipedInput);
        if (tokenMetadata?.token !== undefined) {
            this.tokenMetadata = tokenMetadata;
            this.debug(`Using API token: ${this.apiToken}`);
        }
        else {
            this.debug(`No valid API token found.`);
        }
        // TODO: Change the TP plan from ResourceId (ConfigAPI) to TrackingPlanId (PublicAPI)
        if (this.apiToken !== undefined &&
            this.workspaceConfig?.trackingPlans.some((tp) => tp.id.trimStart().startsWith("rs_"))) {
            this.warn(`Your ${chalk_1.default.green("typewriter.yml")} config file was generated with Typewriter v7, the Tracking Plan ID format has changed in v8, we will attempt to retrieve the new Tracking Plan IDs. You will receive a prompt to save this value for the next run`);
            // We will attempt to fix the tracking plan ids in memory, we won't replace anything without user confirmation as that is a one way operation
            this.debug(`Config file is in v7 ID format, attempting to retrieve the v8 Tracking Plan IDs`);
            try {
                const trackingPlans = await (0, api_1.fetchTrackingPlans)(this.apiToken);
                let hasMissing = false;
                if (trackingPlans !== undefined && trackingPlans.length > 0) {
                    for (const trackingPlan of this.workspaceConfig.trackingPlans) {
                        const newId = trackingPlans.find((tp) => tp.resourceSchemaId === trackingPlan.id);
                        if (newId !== undefined) {
                            trackingPlan.legacyID = trackingPlan.id;
                            trackingPlan.id = newId.id;
                        }
                        else {
                            hasMissing = true;
                            this.debug(`Could not find a Tracking Plan with ResourceID: ${trackingPlan.id}`);
                        }
                    }
                }
                if (hasMissing) {
                    this.warn(`We couldn't find some tracking plan IDs automatically. We recommend reinitializing the config file by running ${chalk_1.default.green("typewriter init")}`);
                }
                else {
                    this.hasConfigUpdates = true;
                }
                this.debug(`Converted v1 config to:`, this.workspaceConfig);
            }
            catch (e) {
                this.debug("Unable to list the tracking plans", e);
            }
        }
        this.debug(`Loaded supported languages:`, languages_1.supportedLanguages);
    }
    async finally(error) {
        await super.finally(error);
        if (this.id !== "init" &&
            error === undefined &&
            !this.isCI &&
            this.workspaceConfig !== undefined &&
            this.hasConfigUpdates) {
            const { updateConfig } = await this.prompt({
                type: "confirm",
                name: "updateConfig",
                default: true,
                message: `Do you want to save the updates to your config file?\n${chalk_1.default.yellow("(After this you won't be able to use Typewriter v7, but will speed up startup time of the next runs)")}`,
            });
            if (updateConfig) {
                await (0, config_1.saveWorkspaceConfig)(this.workspaceConfig, this.configPath);
            }
        }
        // Close the TTY streams after the command is done else the command will hang.
        ttys_1.ttys.stdout?.destroy();
        ttys_1.ttys.stdin?.destroy();
    }
}
exports.BaseCommand = BaseCommand;
BaseCommand.examples = ["<%= config.bin %> <%= command.id %>"];
BaseCommand.flags = {
    config: core_1.Flags.string({
        char: "c",
        description: "Path to the configuration file",
        multiple: false,
        default: DEFAULT_CONFIG_PATH,
    }),
    debug: core_1.Flags.boolean({
        description: "Enable verbose logging",
        default: false,
    }),
};
