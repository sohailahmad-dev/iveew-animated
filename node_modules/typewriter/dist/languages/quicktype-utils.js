"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createQuicktypeLanguageGenerator = exports.generateWithQuicktype = exports.cleanOptions = exports.executeRenderPlan = exports.emitMultiline = exports.createCodeGeneratorsFromTemplates = exports.calculateLineIndentationLevel = exports.getLanguageMetadata = exports.makeNameForTopLevelWithPrefixAndSuffix = void 0;
const tslib_1 = require("tslib");
const debug_1 = require("debug");
const fs = tslib_1.__importStar(require("fs"));
const handlebars_1 = tslib_1.__importDefault(require("handlebars"));
const os_1 = require("os");
const path_1 = require("path");
const quicktype_core_1 = require("quicktype-core");
const Strings_1 = require("quicktype-core/dist/support/Strings");
const TypeUtils_1 = require("quicktype-core/dist/TypeUtils");
const debug = (0, debug_1.debug)("typewriter:quicktype-utils");
const INDENT_SIZE = 4;
function addPrefixAndSuffix(name, prefix, suffix) {
    return `${prefix ?? ""} ${name} ${suffix ?? ""}`;
}
/**
 * Wraps a name modifier with a prefixer and suffixer
 */
const modWithPrefixAndSuffix = (prefix, suffix, modifier) => {
    return (name) => {
        const modName = addPrefixAndSuffix(name, prefix, suffix);
        if (modifier !== undefined) {
            return modifier(modName);
        }
        return modName;
    };
};
/**
 * This is an override for makeNameForTopLevel for our quicktype language renderers
 */
function makeNameForTopLevelWithPrefixAndSuffix(namer, typewriterSettings, t, givenName, maybeNamedType) {
    const { prefix, suffix } = typewriterSettings.typeNameModifiers ?? {};
    const modName = addPrefixAndSuffix(givenName, prefix, suffix);
    return namer(t, modName, maybeNamedType);
}
exports.makeNameForTopLevelWithPrefixAndSuffix = makeNameForTopLevelWithPrefixAndSuffix;
function toInquirerQuestion(option) {
    // Option setting
    if (option.legalValues !== undefined && option.legalValues.length > 0) {
        return {
            type: option.multiple ? "checkbox" : "list",
            name: option.name,
            message: option.description,
            choices: option.legalValues,
            default: option.defaultValue,
        };
    }
    // String setting
    if (option.type === String) {
        return {
            type: "input",
            name: option.name,
            message: option.description,
            default: option.defaultValue,
        };
    }
    // Boolean Option
    return {
        type: "confirm",
        name: option.name,
        message: option.description,
        default: option.defaultValue,
    };
}
/**
 * Gets the language options from Quicktype and returns a Inquirer Prompt friendly object for use within the wizard of the init command
 * @param language the quicktype language name
 * @param unsupportedOptions (optional) array of quicktype options that are not supported to remove from the options
 * @returns LanguageMetadata object with all data required for a LanguageGenerator
 */
function getLanguageMetadata(language, unsupportedOptions = [], requiredOptions = []) {
    const lang = (0, quicktype_core_1.getTargetLanguage)(language);
    const advancedOpts = [];
    const requiredOpts = [];
    for (const opt of lang.optionDefinitions) {
        if (unsupportedOptions.includes(opt.name)) {
            continue;
        }
        const question = toInquirerQuestion(opt);
        if (requiredOptions.includes(opt.name)) {
            requiredOpts.push(question);
        }
        else {
            advancedOpts.push(question);
        }
    }
    return {
        id: lang.name,
        name: lang.displayName,
        extension: lang.extension,
        requiredOptions: requiredOpts,
        advancedOptions: advancedOpts,
    };
}
exports.getLanguageMetadata = getLanguageMetadata;
/**
 * Calculates the correct indentation level for the generated code from a template file line and an input indentation size
 * @param line template file line
 * @param indentSize indent size on the template file
 * @returns an object containing indentation level and the text to output to the generated code
 */
function calculateLineIndentationLevel(line, indentSize = INDENT_SIZE) {
    const len = line.length;
    let indent = 0;
    for (let i = 0; i < len; i++) {
        const c = line.charAt(i);
        if (c === " ") {
            indent += 1;
        }
        else if (c === "\t") {
            indent = (indent / indentSize + 1) * indentSize;
        }
        else {
            return { indent, text: line.substring(i) };
        }
    }
    return { indent: 0, text: null };
}
exports.calculateLineIndentationLevel = calculateLineIndentationLevel;
/**
 * Creates a set of code generators from multiple paths to HandleBars templates
 *
 * @param paths paths to Handlebars templates
 * @returns a set of CodeGenerators
 */
function createCodeGeneratorsFromTemplates(context, nameModifiers, ...paths) {
    return paths.map((path) => createCodeGeneratorFromTemplate(path, context, nameModifiers));
}
exports.createCodeGeneratorsFromTemplates = createCodeGeneratorsFromTemplates;
/**
 * Creates a CodeGenerator from a Handlebars template
 *
 * @param path path to handlebars template
 * @returns a CodeGenerator
 */
function createCodeGeneratorFromTemplate(path, context, nameModifiers) {
    const absolutePath = (0, path_1.resolve)(__dirname, path);
    try {
        const template = fs.readFileSync(absolutePath);
        handlebars_1.default.registerHelper("eq", (a, b) => a === b);
        const generator = handlebars_1.default.compile(template.toString());
        return (renderer) => {
            const tags = {
                type: [],
                version: context.version,
                isDevelopment: context.isDevelopment,
            };
            // @ts-ignore this is a protected method but we need it to access the particulars of each type
            renderer.forEachTopLevel("none", (type, name) => {
                const metadata = type
                    .getAttributes()
                    .get(eventMetadataAttributeKind);
                tags.type.push({
                    eventName: metadata.name,
                    eventType: metadata.type,
                    // @ts-ignore
                    description: renderer.descriptionForType(type)?.join(" "),
                    // @ts-ignore
                    functionName: renderer.sourcelikeToString((0, quicktype_core_1.modifySource)(nameModifiers?.functionName ?? Strings_1.originalWord, name)),
                    // @ts-ignore
                    typeName: renderer.sourcelikeToString(name),
                    rawJSONSchema: JSON.stringify(metadata.raw),
                });
            }, TypeUtils_1.isNamedType);
            return renderer.emitMultiline(generator(tags));
        };
    }
    catch (error) {
        throw new Error(`Error while reading template at ${absolutePath}: ${JSON.stringify(error)}`);
    }
}
/**
 * Overrides the emitMultiline in a Renderer with an option for variable indent sizes
 * @param renderer Quicktype Renderer
 * @param linesString contents to output
 * @param indentSize indent size in spaces number
 * @returns
 */
function emitMultiline(renderer, linesString, indentSize = 4) {
    const lines = linesString.split("\n");
    const numLines = lines.length;
    if (numLines === 0)
        return;
    renderer.emitLine(lines[0]);
    let currentIndent = 0;
    for (let i = 1; i < numLines; i++) {
        const line = lines[i];
        const { indent, text } = calculateLineIndentationLevel(line, indentSize);
        if (text !== null) {
            const newIndent = Math.floor(indent / indentSize);
            const leadSpaces = indent % indentSize;
            renderer.changeIndent(newIndent - currentIndent);
            currentIndent = newIndent;
            renderer.emitLine(" ".repeat(leadSpaces), text);
        }
        else {
            renderer.emitLine();
        }
    }
    if (currentIndent !== 0) {
        renderer.changeIndent(-currentIndent);
    }
}
exports.emitMultiline = emitMultiline;
/**
 * Executes all the CodeGenerators in a RenderPlan, for use in a LanguageRenderer
 * @param renderer A QuickType language Renderer
 * @param templatePlan an array of CodeGenerator functions to execute
 * @param nameModifiers Name Modifiers to apply for functions and types
 */
function executeRenderPlan(renderer, templatePlan) {
    if (templatePlan.length === 0) {
        return;
    }
    renderer.ensureBlankLine();
    for (const plan of templatePlan) {
        plan(renderer);
    }
}
exports.executeRenderPlan = executeRenderPlan;
/**
 * Returns the language options after filtering unsupported settings and
 * applying default values to missing settings
 * @param options Language Generator options
 * @param defaultValues Map of default values for the options
 * @param unsupportedOptions List of unsupported quicktype options
 * @returns A cleaned map of the settings with default values applied
 */
function cleanOptions(options, defaultValues = {}, unsupportedOptions = []) {
    const filteredOptions = Object.fromEntries(Object.entries(options).filter(([key, _]) => !unsupportedOptions.includes(key)));
    return {
        ...defaultValues,
        ...filteredOptions,
    };
}
exports.cleanOptions = cleanOptions;
class EventMetadataAttributeKind extends quicktype_core_1.TypeAttributeKind {
    constructor() {
        super("eventMetadata");
    }
    combine(attrs) {
        return attrs[0];
    }
    makeInferred(_) {
        return undefined;
    }
}
const eventMetadataAttributeKind = new EventMetadataAttributeKind();
/**
 * Extracts and injects the event metadata into the attributes for the quicktype types
 */
function eventAttributesProducer(schema, _canonicalRef, _types) {
    if (typeof schema !== "object" || schema.eventMetadata === undefined)
        return undefined;
    // Remove the eventMetadata from the raw schema
    const { eventMetadata, ...rawSchema } = schema;
    const metadata = eventMetadataAttributeKind.makeAttributes({
        ...schema.eventMetadata,
        raw: rawSchema,
    });
    return { forType: metadata };
}
/**
 * Translates the Segment Protocol Rules into a JSONSchemaInput object for Quicktype
 * @param rules Segment PublicAPI Rules object
 * @returns InputData object for Quicktype to read as a JSON Schema
 */
async function getSchemaInputData(rules) {
    const schemaInput = new quicktype_core_1.JSONSchemaInput(undefined, [eventAttributesProducer]);
    for (const rule of rules ?? []) {
        await schemaInput.addSource({
            name: rule.key,
            schema: JSON.stringify(rule.jsonSchema),
        });
    }
    const inputData = new quicktype_core_1.InputData();
    inputData.addInput(schemaInput);
    return inputData;
}
/**
 * Generates types using Quicktype. Convenience method for calling quicktype with Segment Rules.
 * @param language Quicktype Language
 * @param rules SegmentAPI Tracking Plan Rules
 * @param options Renderer options
 * @returns A File Map of filename : contents
 */
async function generateWithQuicktype(language, rules, options) {
    const { header, sdk, outputFilename, ...rendererOptions } = options;
    const inputData = await getSchemaInputData(rules);
    const files = await (0, quicktype_core_1.quicktypeMultiFile)({
        inputData,
        lang: language,
        leadingComments: header,
        fixedTopLevels: true,
        outputFilename,
        // debugPrintGraph: true,
        rendererOptions: rendererOptions,
    });
    const output = new Map();
    for (const [k, v] of files.entries()) {
        output.set(k, v.lines.join(os_1.EOL));
    }
    return output;
}
exports.generateWithQuicktype = generateWithQuicktype;
/**
 * Creates a LanguageGenerator using Quicktype for the types and Handlebars for templates.
 * @param config a FactoryConfig object
 * @returns a LanguageGenerator object for Typewriter
 */
function createQuicktypeLanguageGenerator(config) {
    const { name, quicktypeLanguage, supportedSDKs, defaultOptions, unsupportedOptions, nameModifiers, requiredOptions, } = config;
    const metadata = getLanguageMetadata(name, unsupportedOptions, requiredOptions);
    const sdks = {};
    const templates = {};
    for (const sdk of supportedSDKs) {
        const id = sdk.id.toLocaleLowerCase();
        sdks[sdk.name] = id;
        templates[id] = sdk.templatePath;
    }
    return {
        id: metadata.id,
        name: metadata.name,
        extension: metadata.extension,
        advancedOptions: metadata.advancedOptions,
        requiredOptions: metadata.requiredOptions,
        supportedSDKs: sdks,
        generate: async (rules, context, options) => {
            const { sdk, prefixes, suffixes } = options;
            let codeGenerators;
            const templatePath = templates[sdk.toLocaleLowerCase()];
            debug("Starting Quicktype Generator for SDK:", sdk, "Language:", metadata.name, "Template Path:", templatePath, "Options", options);
            if (templatePath === undefined) {
                codeGenerators = [];
                debug(`Generate ${metadata.name} just types`);
            }
            else {
                const mods = {
                    functionName: modWithPrefixAndSuffix(prefixes?.functionName, suffixes?.functionName, nameModifiers?.functionName),
                };
                codeGenerators = createCodeGeneratorsFromTemplates(context, mods, templatePath);
                debug(`Generate ${metadata.name} using template: ${templatePath}`);
            }
            return generateWithQuicktype(new quicktypeLanguage({
                generators: codeGenerators,
                typeNameModifiers: {
                    prefix: prefixes?.typeName,
                    suffix: suffixes?.typeName,
                },
            }), rules, cleanOptions(options, defaultOptions, unsupportedOptions));
        },
    };
}
exports.createQuicktypeLanguageGenerator = createQuicktypeLanguageGenerator;
