"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.typescript = void 0;
const tslib_1 = require("tslib");
const path_1 = tslib_1.__importDefault(require("path"));
const quicktype_core_1 = require("quicktype-core");
const RendererOptions_1 = require("quicktype-core/dist/RendererOptions");
const Strings_1 = require("quicktype-core/dist/support/Strings");
const quicktype_utils_1 = require("./quicktype-utils");
// To add our own functions we need to extend the renderer for the language we are targeting
class TypewriterTypescriptRenderer extends quicktype_core_1.TypeScriptRenderer {
    constructor(targetLanguage, renderContext, typescriptOptions, typewriterOptions) {
        super(targetLanguage, renderContext, typescriptOptions);
        this.typewriterOptions = typewriterOptions;
    }
    emitMultiline(linesString) {
        (0, quicktype_utils_1.emitMultiline)(this, linesString, 2);
    }
    emitSource(givenOutputFilename) {
        super.emitSource(givenOutputFilename);
        (0, quicktype_utils_1.executeRenderPlan)(this, this.typewriterOptions.generators);
    }
    makeNameForTopLevel(t, givenName, maybeNamedType) {
        return (0, quicktype_utils_1.makeNameForTopLevelWithPrefixAndSuffix)((...args) => {
            return super.makeNameForTopLevel(...args);
        }, this.typewriterOptions, t, givenName, maybeNamedType);
    }
}
// We extend one of the target languages in quicktype to add our own functions
// This is only necesary to make it use our own renderer
class TypewriterTSLanguage extends quicktype_core_1.TypeScriptTargetLanguage {
    constructor(typewriterOptions) {
        super();
        this.typewriterOptions = typewriterOptions;
    }
    makeRenderer(renderContext, untypedOptionValues) {
        return new TypewriterTypescriptRenderer(this, renderContext, (0, RendererOptions_1.getOptionValues)(quicktype_core_1.tsFlowOptions, untypedOptionValues), this.typewriterOptions);
    }
}
const tsBase = (0, quicktype_utils_1.createQuicktypeLanguageGenerator)({
    name: "typescript",
    quicktypeLanguage: TypewriterTSLanguage,
    supportedSDKs: [
        {
            name: "Node.js (analytics-node)",
            id: "analytics-node",
            templatePath: "templates/typescript/node.hbs",
        },
        {
            name: "Web (analytics.js)",
            id: "analytics-js",
            templatePath: "templates/typescript/analytics-js.hbs",
        },
        {
            name: "React Native (analytics-react-native)",
            id: "analytics-react-native",
            templatePath: "templates/typescript/react-native.hbs",
        },
        {
            name: "None (Types and validation only)",
            id: "none",
        },
    ],
    defaultOptions: {
        "just-types": true,
    },
    nameModifiers: {
        functionName: Strings_1.camelCase,
    },
});
exports.typescript = {
    ...tsBase,
    generate: async (rules, context, options) => {
        const { sdk, prefixes, suffixes } = options;
        const result = await tsBase.generate(rules, context, options);
        // We edit the RN output to include the TSX extension
        if (sdk === "analytics-react-native") {
            const tsxResult = new Map();
            for (const [filename, contents] of result.entries()) {
                if (path_1.default.extname(filename) === ".ts") {
                    tsxResult.set(`${filename}x`, contents);
                }
                else {
                    tsxResult.set(`${filename}.tsx`, contents);
                }
            }
            return tsxResult;
        }
        return result;
    },
};
