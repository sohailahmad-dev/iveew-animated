"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.swift = void 0;
const quicktype_core_1 = require("quicktype-core");
const Strings_1 = require("quicktype-core/dist/support/Strings");
const quicktype_utils_1 = require("./quicktype-utils");
class TypewriterSwiftRenderer extends quicktype_core_1.SwiftRenderer {
    constructor(targetLanguage, renderContext, typescriptOptions, typewriterOptions) {
        super(targetLanguage, renderContext, typescriptOptions);
        this.typewriterOptions = typewriterOptions;
    }
    emitMultiline(linesString) {
        (0, quicktype_utils_1.emitMultiline)(this, linesString, 4);
    }
    emitSource(givenOutputFilename) {
        super.emitSource(givenOutputFilename);
        (0, quicktype_utils_1.executeRenderPlan)(this, this.typewriterOptions.generators);
    }
    makeNameForTopLevel(t, givenName, maybeNamedType) {
        return (0, quicktype_utils_1.makeNameForTopLevelWithPrefixAndSuffix)((...args) => {
            return super.makeNameForTopLevel(...args);
        }, this.typewriterOptions, t, givenName, maybeNamedType);
    }
    getProtocolsArray(t, isClass) {
        let protocols = super.getProtocolsArray(t, isClass);
        // We have to enforce all our classes to be Codable for compatibility with our calls so we enforce this here
        if (!protocols.includes('Codable')) {
            protocols.push('Codable');
        }
        return protocols;
    }
}
class TypewriterSwiftLanguage extends quicktype_core_1.SwiftTargetLanguage {
    constructor(typewriterOptions) {
        super();
        this.typewriterOptions = typewriterOptions;
    }
    makeRenderer(renderContext, untypedOptionValues) {
        return new TypewriterSwiftRenderer(this, renderContext, (0, quicktype_core_1.getOptionValues)(quicktype_core_1.swiftOptions, untypedOptionValues), this.typewriterOptions);
    }
}
exports.swift = (0, quicktype_utils_1.createQuicktypeLanguageGenerator)({
    name: 'swift',
    quicktypeLanguage: TypewriterSwiftLanguage,
    supportedSDKs: [
        {
            name: 'Analytics.Swift',
            id: 'swift',
            templatePath: 'templates/swift/analytics.hbs',
        },
        {
            name: 'None (Types and validation only)',
            id: 'none',
        },
    ],
    // Note, we don't let people set just-types to false cause that will cause undefined arrays in their TrackingPlans to not be compatible with Codable,
    // if we enforce not to use types the generated code will contain a JSONAny class that is codable and compatible with any JSON valid object
    defaultOptions: {
        'just-types': false,
    },
    unsupportedOptions: ['just-types'],
    nameModifiers: {
        functionName: Strings_1.camelCase,
    },
});
