"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toCommandConfig = exports.withContext = exports.getSegmentClient = exports.segmentClient = void 0;
const tslib_1 = require("tslib");
const ci_detect_1 = tslib_1.__importDefault(require("@npmcli/ci-detect"));
const analytics_node_1 = require("@segment/analytics-node");
const node_machine_id_1 = require("node-machine-id");
const config_1 = require("../config");
const segment_1 = tslib_1.__importStar(require("./segment"));
// Initialize the segment client and the typewriter client with our Write Key for telemetry
const writeKey = process.env.NODE_ENV === "production"
    ? // Production: https://app.segment.com/segment_prod/sources/typewriter_next/overview
        "3Q4zXqkF8lcxeMyvfaiEBLhznBrppBWi"
    : // Development: https://app.segment.com/segment_prod/sources/typewriter_next_dev/overview
        "WoCqTlHJKOb9D8NepuSLItTGEkXxLKVV";
const segmentClient = new analytics_node_1.Analytics({
    writeKey,
    maxEventsInBatch: 1,
    // We won't do anything if the analytics client is unable to contact Segment, just prevent a crash
    // @ts-ignore errorHandler is not showing up in the analytics-node types but it is publicly supported
    errorHandler: () => { },
});
exports.segmentClient = segmentClient;
segment_1.default.setTypewriterOptions({
    analytics: segmentClient,
});
/**
 * Adds the Typewriter CLI app context data to the event
 * @param message event
 * @param config OCLIF Config
 * @returns an event with context filled in
 */
const withContext = (message, config, anonymousId) => {
    return {
        ...message,
        anonymousId,
        context: {
            ...(message.context || {}),
            app: {
                name: config.pjson.name,
                version: config.pjson.version,
            },
        },
    };
};
exports.withContext = withContext;
/**
 * Formats the Workspace config into the tracking plan valid command config object
 * @param config OCLIF Config
 * @param tokenMethod Auth Token method used in the command
 * @returns a tracking plan compatible config object
 */
const toCommandConfig = (config, tokenMethod) => {
    const { language, sdk, ...opts } = config.client;
    return {
        language,
        sdk,
        languageOptions: opts,
        trackingPlans: config.trackingPlans.map((plan) => ({
            id: plan.id,
            path: plan.path,
        })),
        tokenType: tokenMethod !== undefined ? toTelemetryTokenType(tokenMethod) : undefined,
    };
};
exports.toCommandConfig = toCommandConfig;
/**
 * Maps between the CLI TokenMethod enum to the TokenType from the tracking plan
 * @param token Auth Token method used in the command
 * @returns a TokenType
 */
const toTelemetryTokenType = (token) => {
    const map = {
        [config_1.TokenMethod.Pipe]: segment_1.TokenType.Input,
        [config_1.TokenMethod.File]: segment_1.TokenType.Global,
        [config_1.TokenMethod.Script]: segment_1.TokenType.Script,
    };
    return map[token];
};
const addContextParams = (fn, config, anonymousId) => {
    return (message, callback) => {
        fn(withContext(message, config, anonymousId), callback);
    };
};
const getSegmentClient = (config) => {
    let anonymousId = "unknown";
    try {
        anonymousId = (0, node_machine_id_1.machineIdSync)();
    }
    catch (error) {
        segment_1.default.commandError(withContext({
            properties: {
                error: error,
                isCI: `${(0, ci_detect_1.default)()}`,
                rawCommand: '',
                errorMessage: `Failed to generate an anonymous id: ${error}`,
            },
        }, config, anonymousId));
    }
    return {
        buildCommand: addContextParams(segment_1.default.commandBuild, config, anonymousId),
        helpCommand: addContextParams(segment_1.default.commandHelp, config, anonymousId),
        initCommand: addContextParams(segment_1.default.commandInit, config, anonymousId),
        commandError: addContextParams(segment_1.default.commandError, config, anonymousId),
        closeAndFlush: () => {
            return segmentClient.closeAndFlush();
        },
    };
};
exports.getSegmentClient = getSegmentClient;
tslib_1.__exportStar(require("./segment"), exports);
