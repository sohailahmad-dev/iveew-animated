"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const fs = tslib_1.__importStar(require("fs"));
const path = tslib_1.__importStar(require("path"));
const core_1 = require("@oclif/core");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const figures_1 = tslib_1.__importDefault(require("figures"));
const api_1 = require("../api");
const base_command_1 = require("../base-command");
const config_1 = require("../config");
const languages_1 = require("../languages");
const telemetry_1 = require("../telemetry");
const lodash_1 = require("lodash");
const FILE_HEADER = [
    "This client was automatically generated by Segment Typewriter. ** Do Not Edit **",
    "To update this file, run:",
    "  npx typewriter",
];
class Build extends base_command_1.BaseCommand {
    // clearFolder removes all typewriter-generated files from the specified folder
    // except for a plan.json.
    // It uses a simple heuristic to avoid accidentally clobbering a user's files --
    // it only clears files with the "this file was autogenerated by Typewriter" warning.
    // Therefore, all generators need to output that warning in a comment in the first few
    // lines of every generated file.
    clearFolder(dir) {
        const fileNames = fs.readdirSync(dir, "utf-8");
        for (const fileName of fileNames) {
            const fullPath = path.join(dir, fileName);
            try {
                const contents = fs.readFileSync(fullPath, "utf-8");
                if (contents.includes(FILE_HEADER[0])) {
                    this.debug("Deleting file:", fullPath);
                    fs.unlinkSync(fullPath);
                }
            }
            catch (error) {
                // Note: none of our generators produce folders, but if we ever do, then we'll need to
                // update this logic to handle recursively traversing directores. For now, we just ignore
                // any directories.
                throw error;
            }
        }
    }
    async clearGeneratedFiles(trackingPlanConfig) {
        const path = (0, config_1.resolveRelativePath)(this.configPath, trackingPlanConfig.path);
        await (0, config_1.verifyDirectoryExists)(path);
        try {
            this.debug("Clearing directory:", path);
            await this.clearFolder(path);
        }
        catch (error) {
            this.debug(`Failed to clear generated files in: '${trackingPlanConfig.path}'`);
        }
    }
    formatQuestion(question, tips) {
        let tipsText = "";
        if (tips !== undefined) {
            tipsText = tips
                .map((tip) => chalk_1.default.gray(`${figures_1.default.arrowRight} ${tip}`))
                .join("\n");
        }
        return [question, tipsText, chalk_1.default.white(figures_1.default.pointer)].join("\n");
    }
    async run() {
        const startTime = process.hrtime();
        const { flags } = await this.parse(this.constructor);
        // Check we have all the information we need
        if (this.apiToken === undefined && flags.token === undefined) {
            this.warn(`No API token found at ${this.configPath}. Using local copy of tracking plans instead.`);
        }
        if (this.workspaceConfig === undefined) {
            this.error(`No workspace config found at ${this.configPath}. Run init first to generate a configuration file.`);
        }
        const configPlans = this.workspaceConfig?.trackingPlans ?? [];
        if (configPlans.length === 0) {
            this.error(`No tracking plans found on ${this.configPath}. Run init first to generate a config file.`);
        }
        if (flags.update === false) {
            this.log(chalk_1.default.gray(`Running build without ${chalk_1.default.yellow(`--update`)} flag. Build will not pull down tracking plan changes from Segment. \nRun ${chalk_1.default.yellow(this.rawCommand)} ${chalk_1.default.yellow(`--update`)} to fetch and build or manually update without building by running ${chalk_1.default.yellow(`typewriter update`)}.\n`));
        }
        core_1.CliUx.ux.action.start("Loading tracking plans");
        const trackingPlans = await (0, api_1.loadTrackingPlans)(flags.token ?? this.apiToken, this.configPath, flags.id
            ? this.workspaceConfig.trackingPlans.filter((plan) => plan.id === flags.id)
            : this.workspaceConfig.trackingPlans, flags.update);
        this.debug("Loaded Tracking Plans:\n", trackingPlans);
        core_1.CliUx.ux.action.stop(chalk_1.default.green(`Loaded`));
        let { language, sdk, languageOptions } = this.workspaceConfig.client;
        language = flags.language || language;
        sdk = flags.sdk || sdk;
        const languageGenerator = languages_1.supportedLanguages.find((lang) => lang.id === language);
        if (languageGenerator === undefined) {
            this.error(`Could not find a language generator for: ${language}`);
        }
        this.debug(`Generating code. Language: ${language}, SDK: ${sdk} Options:`, languageOptions);
        core_1.CliUx.ux.action.start("Generating files");
        for (const plan of trackingPlans) {
            if (plan.rules === undefined || plan.rules.length === 0) {
                core_1.CliUx.ux.action.status = chalk_1.default.yellow(`No rules found for ${plan.name}. Skipping...`);
                continue;
            }
            for (const rule of plan.rules) {
                if ((0, lodash_1.isEmpty)(rule.jsonSchema.properties)) {
                    rule.jsonSchema.properties = {
                        _: {
                            type: "null",
                            $id: "/properties/_",
                            description: "This property is added as a workaround to generate type for events without properties",
                        },
                    };
                }
            }
            try {
                const files = await languageGenerator.generate(plan.rules ?? [], {
                    version: this.config.version,
                    isDevelopment: flags.mode === "dev",
                }, {
                    header: FILE_HEADER,
                    outputFilename: "segment",
                    sdk: sdk,
                    ...languageOptions,
                });
                const workspacePlan = this.workspaceConfig.trackingPlans.find((tp) => tp.id === plan.id || tp.legacyID === plan.id);
                await this.clearGeneratedFiles(workspacePlan);
                for (const [filename, contents] of files.entries()) {
                    // Not all quicktype languages add their extensions in the filenames returned so we check here to add it ourselves
                    let fileWithExtension = `${filename}`;
                    if (path.extname(filename) === "") {
                        fileWithExtension += `.${languageGenerator.extension}`;
                    }
                    const filepath = (0, config_1.resolveRelativePath)(this.configPath, flags.path || workspacePlan.path, fileWithExtension);
                    this.debug(`Writing to ${filepath}`);
                    await (0, config_1.verifyDirectoryExists)(filepath, "file");
                    fs.writeFileSync(filepath, contents, {
                        encoding: "utf-8",
                    });
                }
            }
            catch (error) {
                core_1.CliUx.ux.action.stop(chalk_1.default.red("Error!"));
                this.error(error, {
                    message: `Failed to generate language for ${plan.name}: ${error}`,
                });
            }
        }
        core_1.CliUx.ux.action.stop(chalk_1.default.green(`Done`));
        this.segmentClient.buildCommand({
            properties: {
                config: (0, telemetry_1.toCommandConfig)(this.workspaceConfig, this.tokenMetadata?.method),
                isCI: `${this.isCI}`,
                mode: flags.mode === "dev" ? telemetry_1.Mode.Dev : telemetry_1.Mode.Prod,
                workspace: this.workspace?.id,
                duration: process.hrtime(startTime)[1],
                rawCommand: this.rawCommand,
            },
        });
        const afterScript = this.workspaceConfig.scripts?.after;
        if (afterScript !== undefined) {
            core_1.CliUx.ux.action.start(`Running After Script: ${chalk_1.default.blue(afterScript)}`);
            await (0, config_1.runScript)(afterScript, this.configPath, config_1.Scripts.After);
            core_1.CliUx.ux.action.stop(chalk_1.default.green(`Done`));
        }
    }
}
exports.default = Build;
Build.description = "Generates types and functions for your tracking plan";
Build.aliases = ["b"];
Build.examples = [
    "<%= config.bin %> <%= command.id %>",
    "<%= config.bin %> <%= command.id %> -u",
    "<%= config.bin %> <%= command.id %> -m prod -u",
];
Build.flags = {
    ...base_command_1.BaseCommand.flags,
    update: core_1.Flags.boolean({
        char: "u",
        default: false,
        description: "Download the latest Tracking Plan version from Segment",
    }),
    mode: core_1.Flags.enum({
        options: ["dev", "prod"],
        default: "dev",
        required: false,
        char: "m",
        description: "Switch between production more or development mode (with additional validation generated for some languages)",
    }),
    token: core_1.Flags.string({
        char: "t",
        required: false,
        description: "Pass API token for fetching the tracking plan from Segment",
    }),
    id: core_1.Flags.string({
        char: "i",
        required: false,
        description: "Tracking plan id",
    }),
    path: core_1.Flags.string({
        char: "p",
        required: false,
        description: "Update path for tracking plan files",
    }),
    language: core_1.Flags.string({
        char: "l",
        required: false,
        description: "Set language for tracking plan file",
    }),
    sdk: core_1.Flags.string({
        char: "s",
        required: false,
        description: "Set SDK for tracking plan file",
    }),
};
