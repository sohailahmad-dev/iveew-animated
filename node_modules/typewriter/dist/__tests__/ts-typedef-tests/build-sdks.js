"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildSDKs = void 0;
const tslib_1 = require("tslib");
const node_fs_1 = tslib_1.__importDefault(require("node:fs"));
const node_path_1 = tslib_1.__importDefault(require("node:path"));
const environment_1 = require("../__helpers__/environment");
const oclif_runner_1 = require("../__helpers__/oclif-runner");
const TEST_ENV_PATH = "production";
const configurations = [
    ["typescript", "analytics-node", "segment.ts"],
    ["typescript", "analytics-js", "segment.ts"],
];
const buildSDKs = async () => {
    for (const config of configurations) {
        const [language, sdk, filename, plan, id, outputPath, legacyId] = config;
        const testPath = await (0, environment_1.setupEnv)(TEST_ENV_PATH, language, sdk, plan, id, outputPath, legacyId);
        await (0, oclif_runner_1.run)(["production", "-c", testPath]);
        // basically, we write the test files to a new build path relative to this script.
        // typechecking ./test-env directly is a little complicated because of .tsconfig configuration + hashed directory name
        const output = node_fs_1.default
            .readFileSync(node_path_1.default.join(testPath, filename), {
            encoding: "utf-8",
        })
            .replace(/version:.*\d.*/g, "");
        const BUILD_PATH = node_path_1.default.resolve(__dirname, "build");
        if (!node_fs_1.default.existsSync(BUILD_PATH)) {
            node_fs_1.default.mkdirSync(BUILD_PATH);
        }
        node_fs_1.default.writeFileSync(node_path_1.default.resolve(BUILD_PATH, `${language}-${sdk}.ts`), output, { encoding: "utf-8" });
    }
};
exports.buildSDKs = buildSDKs;
