"use strict";
// This client was automatically generated by Segment Typewriter. ** Do Not Edit **
// To update this file, run:
//   npx typewriter
Object.defineProperty(exports, "__esModule", { value: true });
exports.noIDType = exports.purpleEventCollided = exports.unionType = exports.simpleArrayTypes = exports.propertySanitized = exports.propertyObjectNameCollision2 = exports.propertyObjectNameCollision1 = exports.propertiesCollided = exports.nestedObjects = exports.nestedArrays = exports.largeNumbersEvent = exports.everyRequiredType = exports.everyOptionalType = exports.everyNullableRequiredType = exports.everyNullableOptionalType = exports.eventCollided = exports.enumTypes = exports.emptyEvent = exports.defaultViolationHandlerCalled = exports.defaultViolationHandler = exports.customViolationHandlerCalled = exports.customViolationHandler = exports.analyticsInstanceMissingThrewError = exports.analyticsInstanceMissing = exports.the42TerribleEventName3 = exports.setTypewriterOptions = exports.defaultValidationErrorHandler = exports.StringEnum = exports.StringConst = void 0;
/**
 * A string property that only accepts a single enum value.
 */
var StringConst;
(function (StringConst) {
    StringConst["RickSanchez"] = "Rick Sanchez";
})(StringConst = exports.StringConst || (exports.StringConst = {}));
/**
 * A string property that accepts multiple enum values.
 */
var StringEnum;
(function (StringEnum) {
    StringEnum["EvilMorty"] = "Evil Morty";
    StringEnum["LawyerMorty"] = "Lawyer Morty";
})(StringEnum = exports.StringEnum || (exports.StringEnum = {}));
/**
 * The default handler that is fired if none is supplied with setTypewriterOptions.
 * If NODE_ENV="test", this handler will throw an error. Otherwise, it will log
 * a warning message to the console.
 */
const defaultValidationErrorHandler = (message, violations) => {
    const msg = JSON.stringify({
        type: 'Typewriter JSON Schema Validation Error',
        description: `You made an analytics call (${message.event}) using Typewriter that doesn't match the ` +
            'Tracking Plan spec.',
        errors: violations,
    }, undefined, 2);
    if (process.env.NODE_ENV === 'test') {
        throw new Error(msg);
    }
    console.warn(msg);
};
exports.defaultValidationErrorHandler = defaultValidationErrorHandler;
const missingAnalyticsNodeError = new Error(`You must set an analytics-node instance:

>	import { Analytics } from '@segment/analytics-node'
>	import { setTypewriterOptions } from './analytics'
>
> const analytics = new Analytics({ writeKey: 'SEGMENT_WRITE_KEY' })
>	setTypewriterOptions({ analytics: analytics	})

For more information on @segment/analytics-node, see: https://segment.com/docs/sources/server/node/quickstart/
`);
let analytics = () => {
    throw missingAnalyticsNodeError;
};
/**
 * Updates the run-time configuration of this Typewriter client.
 * This function must be called with a configured analytics-node instance before firing
 * any analytics calls, or else a `missingAnalyticsNodeError` error will be thrown.
 *
 * @param {TypewriterOptions} options - the options to upsert
 *
 * @typedef {Object} TypewriterOptions
 * @property {Analytics} analytics - Underlying analytics instance where analytics
 * 		calls are forwarded on to.
 * @property {Function} [onViolation] - Handler fired when if an event does not match its spec. This handler does not fire in
 * 		production mode, because it requires inlining the full JSON Schema spec for each event in your Tracking Plan. By default,
 * 		it will throw errors if NODE_ENV="test" so that tests will fail if a message does not match the spec. Otherwise, errors
 * 		will be logged to stderr.
 */
function setTypewriterOptions(options) {
    analytics = options.analytics ? () => options.analytics : analytics;
}
exports.setTypewriterOptions = setTypewriterOptions;
/**
 * Helper to attach metadata on Typewriter to outbound requests.
 * This is used for attribution and debugging by the Segment team.
 */
function withTypewriterContext(message) {
    return {
        ...message,
        context: {
            ...(message.context || {}),
            typewriter: {
                language: 'typescript',
            },
        },
    };
}
/**
 * Fires a '42_--terrible&#x3D;&#x3D;\&quot;event&#x27;++name~!3' track call.
 * Validates that clients properly sanitize event names.
 *
 * @param {TrackMessage<The42_TerribleEventName3>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
function the42TerribleEventName3(message, callback) {
    const event = withTypewriterContext({
        ...message,
        event: '42_--terrible&#x3D;&#x3D;\&quot;event&#x27;++name~!3',
        properties: {
            ...message.properties,
        },
    });
    const a = analytics();
    if (a) {
        a.track(event, callback);
    }
    else {
        throw missingAnalyticsNodeError;
    }
}
exports.the42TerribleEventName3 = the42TerribleEventName3;
/**
 * Fires a 'Analytics Instance Missing' track call.
 * Fired before an analytics instance has been set, which should throw an error.
 *
 * @param {TrackMessage<AnalyticsInstanceMissing>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
function analyticsInstanceMissing(message, callback) {
    const event = withTypewriterContext({
        ...message,
        event: 'Analytics Instance Missing',
        properties: {
            ...message.properties,
        },
    });
    const a = analytics();
    if (a) {
        a.track(event, callback);
    }
    else {
        throw missingAnalyticsNodeError;
    }
}
exports.analyticsInstanceMissing = analyticsInstanceMissing;
/**
 * Fires a 'Analytics Instance Missing Threw Error' track call.
 * Fired after a client throws an &quot;Analytics Instance Missing&quot; error to mark the test as successful.
 *
 * @param {TrackMessage<AnalyticsInstanceMissingThrewError>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
function analyticsInstanceMissingThrewError(message, callback) {
    const event = withTypewriterContext({
        ...message,
        event: 'Analytics Instance Missing Threw Error',
        properties: {
            ...message.properties,
        },
    });
    const a = analytics();
    if (a) {
        a.track(event, callback);
    }
    else {
        throw missingAnalyticsNodeError;
    }
}
exports.analyticsInstanceMissingThrewError = analyticsInstanceMissingThrewError;
/**
 * Fires a 'Custom Violation Handler' track call.
 * This event is fired in order to trigger a custom violation handler. It should be called with a JSON Schema violation.
 *
 * @param {TrackMessage<CustomViolationHandler>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
function customViolationHandler(message, callback) {
    const event = withTypewriterContext({
        ...message,
        event: 'Custom Violation Handler',
        properties: {
            ...message.properties,
        },
    });
    const a = analytics();
    if (a) {
        a.track(event, callback);
    }
    else {
        throw missingAnalyticsNodeError;
    }
}
exports.customViolationHandler = customViolationHandler;
/**
 * Fires a 'Custom Violation Handler Called' track call.
 * This event should be fired if a custom violation handler is correctly called due to a call to &#x60;Custom Violation Handler&#x60; with a violation.
 *
 * @param {TrackMessage<CustomViolationHandlerCalled>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
function customViolationHandlerCalled(message, callback) {
    const event = withTypewriterContext({
        ...message,
        event: 'Custom Violation Handler Called',
        properties: {
            ...message.properties,
        },
    });
    const a = analytics();
    if (a) {
        a.track(event, callback);
    }
    else {
        throw missingAnalyticsNodeError;
    }
}
exports.customViolationHandlerCalled = customViolationHandlerCalled;
/**
 * Fires a 'Default Violation Handler' track call.
 * This event is fired in order to trigger the default violation handler. It should be called with a JSON Schema violation.
 *
 * @param {TrackMessage<DefaultViolationHandler>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
function defaultViolationHandler(message, callback) {
    const event = withTypewriterContext({
        ...message,
        event: 'Default Violation Handler',
        properties: {
            ...message.properties,
        },
    });
    const a = analytics();
    if (a) {
        a.track(event, callback);
    }
    else {
        throw missingAnalyticsNodeError;
    }
}
exports.defaultViolationHandler = defaultViolationHandler;
/**
 * Fires a 'Default Violation Handler Called' track call.
 * This event should be fired if the default violation handler is correctly called due to a call to &#x60;Default Violation Handler&#x60; with a violation.
 *
 * @param {TrackMessage<DefaultViolationHandlerCalled>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
function defaultViolationHandlerCalled(message, callback) {
    const event = withTypewriterContext({
        ...message,
        event: 'Default Violation Handler Called',
        properties: {
            ...message.properties,
        },
    });
    const a = analytics();
    if (a) {
        a.track(event, callback);
    }
    else {
        throw missingAnalyticsNodeError;
    }
}
exports.defaultViolationHandlerCalled = defaultViolationHandlerCalled;
/**
 * Fires a 'Empty Event' track call.
 * Validates that a generated client supports events with no explicit properties. It is expected that this event accepts ANY properties.
 *
 * @param {TrackMessage<EmptyEvent>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
function emptyEvent(message, callback) {
    const event = withTypewriterContext({
        ...message,
        event: 'Empty Event',
        properties: {
            ...message.properties,
        },
    });
    const a = analytics();
    if (a) {
        a.track(event, callback);
    }
    else {
        throw missingAnalyticsNodeError;
    }
}
exports.emptyEvent = emptyEvent;
/**
 * Fires a 'Enum Types' track call.
 * Validates that client property sanitize enums.
 *
 * @param {TrackMessage<EnumTypes>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
function enumTypes(message, callback) {
    const event = withTypewriterContext({
        ...message,
        event: 'Enum Types',
        properties: {
            ...message.properties,
        },
    });
    const a = analytics();
    if (a) {
        a.track(event, callback);
    }
    else {
        throw missingAnalyticsNodeError;
    }
}
exports.enumTypes = enumTypes;
/**
 * Fires a 'Event Collided' track call.
 * Validates that a generated client handles even naming collisions.
 *
 * @param {TrackMessage<EventCollided>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
function eventCollided(message, callback) {
    const event = withTypewriterContext({
        ...message,
        event: 'Event Collided',
        properties: {
            ...message.properties,
        },
    });
    const a = analytics();
    if (a) {
        a.track(event, callback);
    }
    else {
        throw missingAnalyticsNodeError;
    }
}
exports.eventCollided = eventCollided;
/**
 * Fires a 'Every Nullable Optional Type' track call.
 * Validates that clients handle all of the supported field types, as nullable optional fields. If a field is null, it is expected to be NOT sent through.
 *
 * @param {TrackMessage<EveryNullableOptionalType>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
function everyNullableOptionalType(message, callback) {
    const event = withTypewriterContext({
        ...message,
        event: 'Every Nullable Optional Type',
        properties: {
            ...message.properties,
        },
    });
    const a = analytics();
    if (a) {
        a.track(event, callback);
    }
    else {
        throw missingAnalyticsNodeError;
    }
}
exports.everyNullableOptionalType = everyNullableOptionalType;
/**
 * Fires a 'Every Nullable Required Type' track call.
 * Validates that clients handle all of the supported field types, as nullable required fields. If a field is null, it is expected to be sent through.
 *
 * @param {TrackMessage<EveryNullableRequiredType>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
function everyNullableRequiredType(message, callback) {
    const event = withTypewriterContext({
        ...message,
        event: 'Every Nullable Required Type',
        properties: {
            ...message.properties,
        },
    });
    const a = analytics();
    if (a) {
        a.track(event, callback);
    }
    else {
        throw missingAnalyticsNodeError;
    }
}
exports.everyNullableRequiredType = everyNullableRequiredType;
/**
 * Fires a 'Every Optional Type' track call.
 * Validates that clients handle all of the supported field types, as optional fields.
 *
 * @param {TrackMessage<EveryOptionalType>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
function everyOptionalType(message, callback) {
    const event = withTypewriterContext({
        ...message,
        event: 'Every Optional Type',
        properties: {
            ...message.properties,
        },
    });
    const a = analytics();
    if (a) {
        a.track(event, callback);
    }
    else {
        throw missingAnalyticsNodeError;
    }
}
exports.everyOptionalType = everyOptionalType;
/**
 * Fires a 'Every Required Type' track call.
 * Validates that clients handle all of the supported field types, as required fields.
 *
 * @param {TrackMessage<EveryRequiredType>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
function everyRequiredType(message, callback) {
    const event = withTypewriterContext({
        ...message,
        event: 'Every Required Type',
        properties: {
            ...message.properties,
        },
    });
    const a = analytics();
    if (a) {
        a.track(event, callback);
    }
    else {
        throw missingAnalyticsNodeError;
    }
}
exports.everyRequiredType = everyRequiredType;
/**
 * Fires a 'Large Numbers Event' track call.
 * Validates that clients correctly serialize large numbers (integers and floats).
 *
 * @param {TrackMessage<LargeNumbersEvent>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
function largeNumbersEvent(message, callback) {
    const event = withTypewriterContext({
        ...message,
        event: 'Large Numbers Event',
        properties: {
            ...message.properties,
        },
    });
    const a = analytics();
    if (a) {
        a.track(event, callback);
    }
    else {
        throw missingAnalyticsNodeError;
    }
}
exports.largeNumbersEvent = largeNumbersEvent;
/**
 * Fires a 'Nested Arrays' track call.
 * Validates that clients handle arrays-within-arrays.
 *
 * @param {TrackMessage<NestedArrays>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
function nestedArrays(message, callback) {
    const event = withTypewriterContext({
        ...message,
        event: 'Nested Arrays',
        properties: {
            ...message.properties,
        },
    });
    const a = analytics();
    if (a) {
        a.track(event, callback);
    }
    else {
        throw missingAnalyticsNodeError;
    }
}
exports.nestedArrays = nestedArrays;
/**
 * Fires a 'Nested Objects' track call.
 * Validates that clients handle objects-within-objects.
 *
 * @param {TrackMessage<NestedObjects>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
function nestedObjects(message, callback) {
    const event = withTypewriterContext({
        ...message,
        event: 'Nested Objects',
        properties: {
            ...message.properties,
        },
    });
    const a = analytics();
    if (a) {
        a.track(event, callback);
    }
    else {
        throw missingAnalyticsNodeError;
    }
}
exports.nestedObjects = nestedObjects;
/**
 * Fires a 'Properties Collided' track call.
 * Validates that clients handle collisions in property names within a single event.
 *
 * @param {TrackMessage<PropertiesCollided>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
function propertiesCollided(message, callback) {
    const event = withTypewriterContext({
        ...message,
        event: 'Properties Collided',
        properties: {
            ...message.properties,
        },
    });
    const a = analytics();
    if (a) {
        a.track(event, callback);
    }
    else {
        throw missingAnalyticsNodeError;
    }
}
exports.propertiesCollided = propertiesCollided;
/**
 * Fires a 'Property Object Name Collision #1' track call.
 * Validates that clients handle collisions in object names across multiple events.
 *
 * @param {TrackMessage<PropertyObjectNameCollision1>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
function propertyObjectNameCollision1(message, callback) {
    const event = withTypewriterContext({
        ...message,
        event: 'Property Object Name Collision #1',
        properties: {
            ...message.properties,
        },
    });
    const a = analytics();
    if (a) {
        a.track(event, callback);
    }
    else {
        throw missingAnalyticsNodeError;
    }
}
exports.propertyObjectNameCollision1 = propertyObjectNameCollision1;
/**
 * Fires a 'Property Object Name Collision #2' track call.
 * Validates that clients handle collisions in object names across multiple events.
 *
 * @param {TrackMessage<PropertyObjectNameCollision2>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
function propertyObjectNameCollision2(message, callback) {
    const event = withTypewriterContext({
        ...message,
        event: 'Property Object Name Collision #2',
        properties: {
            ...message.properties,
        },
    });
    const a = analytics();
    if (a) {
        a.track(event, callback);
    }
    else {
        throw missingAnalyticsNodeError;
    }
}
exports.propertyObjectNameCollision2 = propertyObjectNameCollision2;
/**
 * Fires a 'Property Sanitized' track call.
 * Validates that clients sanitize property names that contain invalid identifier characters.
 *
 * @param {TrackMessage<PropertySanitized>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
function propertySanitized(message, callback) {
    const event = withTypewriterContext({
        ...message,
        event: 'Property Sanitized',
        properties: {
            ...message.properties,
        },
    });
    const a = analytics();
    if (a) {
        a.track(event, callback);
    }
    else {
        throw missingAnalyticsNodeError;
    }
}
exports.propertySanitized = propertySanitized;
/**
 * Fires a 'Simple Array Types' track call.
 * Validates that clients support fields with various types of arrays.
 *
 * @param {TrackMessage<SimpleArrayTypes>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
function simpleArrayTypes(message, callback) {
    const event = withTypewriterContext({
        ...message,
        event: 'Simple Array Types',
        properties: {
            ...message.properties,
        },
    });
    const a = analytics();
    if (a) {
        a.track(event, callback);
    }
    else {
        throw missingAnalyticsNodeError;
    }
}
exports.simpleArrayTypes = simpleArrayTypes;
/**
 * Fires a 'Union Type' track call.
 * Validates that clients support fields with multiple (union) types.
 *
 * @param {TrackMessage<UnionType>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
function unionType(message, callback) {
    const event = withTypewriterContext({
        ...message,
        event: 'Union Type',
        properties: {
            ...message.properties,
        },
    });
    const a = analytics();
    if (a) {
        a.track(event, callback);
    }
    else {
        throw missingAnalyticsNodeError;
    }
}
exports.unionType = unionType;
/**
 * Fires a 'event_collided' track call.
 * Validates that a generated client handles even naming collisions.
 *
 * @param {TrackMessage<PurpleEventCollided>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
function purpleEventCollided(message, callback) {
    const event = withTypewriterContext({
        ...message,
        event: 'event_collided',
        properties: {
            ...message.properties,
        },
    });
    const a = analytics();
    if (a) {
        a.track(event, callback);
    }
    else {
        throw missingAnalyticsNodeError;
    }
}
exports.purpleEventCollided = purpleEventCollided;
/**
 * Fires a 'NoID type' track call.
 * Properties without IDs
 *
 * @param {TrackMessage<NoIDType>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
function noIDType(message, callback) {
    const event = withTypewriterContext({
        ...message,
        event: 'NoID type',
        properties: {
            ...message.properties,
        },
    });
    const a = analytics();
    if (a) {
        a.track(event, callback);
    }
    else {
        throw missingAnalyticsNodeError;
    }
}
exports.noIDType = noIDType;
const clientAPI = {
    /**
     * Updates the run-time configuration of this Typewriter client.
     * This function must be called with a configured analytics-node instance before firing
     * any analytics calls, or else a `missingAnalyticsNodeError` error will be thrown.
     *
     * @param {TypewriterOptions} options - the options to upsert
     *
     * @typedef {Object} TypewriterOptions
     * @property {Analytics} analytics - Underlying analytics instance where analytics
     * 		calls are forwarded on to.
     * @property {Function} [onViolation] - Handler fired when if an event does not match its spec. This handler does not fire in
     * 		production mode, because it requires inlining the full JSON Schema spec for each event in your Tracking Plan. By default,
     * 		it will throw errors if NODE_ENV="test" so that tests will fail if a message does not match the spec. Otherwise, errors
     * 		will be logged to stderr.
     */
    setTypewriterOptions,
    /**
     * Fires a '42_--terrible&#x3D;&#x3D;\&quot;event&#x27;++name~!3' track call.
     * Validates that clients properly sanitize event names.
     *
     * @param The42_TerribleEventName3 props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    the42TerribleEventName3,
    /**
     * Fires a 'Analytics Instance Missing' track call.
     * Fired before an analytics instance has been set, which should throw an error.
     *
     * @param AnalyticsInstanceMissing props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    analyticsInstanceMissing,
    /**
     * Fires a 'Analytics Instance Missing Threw Error' track call.
     * Fired after a client throws an &quot;Analytics Instance Missing&quot; error to mark the test as successful.
     *
     * @param AnalyticsInstanceMissingThrewError props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    analyticsInstanceMissingThrewError,
    /**
     * Fires a 'Custom Violation Handler' track call.
     * This event is fired in order to trigger a custom violation handler. It should be called with a JSON Schema violation.
     *
     * @param CustomViolationHandler props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    customViolationHandler,
    /**
     * Fires a 'Custom Violation Handler Called' track call.
     * This event should be fired if a custom violation handler is correctly called due to a call to &#x60;Custom Violation Handler&#x60; with a violation.
     *
     * @param CustomViolationHandlerCalled props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    customViolationHandlerCalled,
    /**
     * Fires a 'Default Violation Handler' track call.
     * This event is fired in order to trigger the default violation handler. It should be called with a JSON Schema violation.
     *
     * @param DefaultViolationHandler props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    defaultViolationHandler,
    /**
     * Fires a 'Default Violation Handler Called' track call.
     * This event should be fired if the default violation handler is correctly called due to a call to &#x60;Default Violation Handler&#x60; with a violation.
     *
     * @param DefaultViolationHandlerCalled props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    defaultViolationHandlerCalled,
    /**
     * Fires a 'Empty Event' track call.
     * Validates that a generated client supports events with no explicit properties. It is expected that this event accepts ANY properties.
     *
     * @param EmptyEvent props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    emptyEvent,
    /**
     * Fires a 'Enum Types' track call.
     * Validates that client property sanitize enums.
     *
     * @param EnumTypes props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    enumTypes,
    /**
     * Fires a 'Event Collided' track call.
     * Validates that a generated client handles even naming collisions.
     *
     * @param EventCollided props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    eventCollided,
    /**
     * Fires a 'Every Nullable Optional Type' track call.
     * Validates that clients handle all of the supported field types, as nullable optional fields. If a field is null, it is expected to be NOT sent through.
     *
     * @param EveryNullableOptionalType props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    everyNullableOptionalType,
    /**
     * Fires a 'Every Nullable Required Type' track call.
     * Validates that clients handle all of the supported field types, as nullable required fields. If a field is null, it is expected to be sent through.
     *
     * @param EveryNullableRequiredType props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    everyNullableRequiredType,
    /**
     * Fires a 'Every Optional Type' track call.
     * Validates that clients handle all of the supported field types, as optional fields.
     *
     * @param EveryOptionalType props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    everyOptionalType,
    /**
     * Fires a 'Every Required Type' track call.
     * Validates that clients handle all of the supported field types, as required fields.
     *
     * @param EveryRequiredType props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    everyRequiredType,
    /**
     * Fires a 'Large Numbers Event' track call.
     * Validates that clients correctly serialize large numbers (integers and floats).
     *
     * @param LargeNumbersEvent props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    largeNumbersEvent,
    /**
     * Fires a 'Nested Arrays' track call.
     * Validates that clients handle arrays-within-arrays.
     *
     * @param NestedArrays props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    nestedArrays,
    /**
     * Fires a 'Nested Objects' track call.
     * Validates that clients handle objects-within-objects.
     *
     * @param NestedObjects props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    nestedObjects,
    /**
     * Fires a 'Properties Collided' track call.
     * Validates that clients handle collisions in property names within a single event.
     *
     * @param PropertiesCollided props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    propertiesCollided,
    /**
     * Fires a 'Property Object Name Collision #1' track call.
     * Validates that clients handle collisions in object names across multiple events.
     *
     * @param PropertyObjectNameCollision1 props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    propertyObjectNameCollision1,
    /**
     * Fires a 'Property Object Name Collision #2' track call.
     * Validates that clients handle collisions in object names across multiple events.
     *
     * @param PropertyObjectNameCollision2 props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    propertyObjectNameCollision2,
    /**
     * Fires a 'Property Sanitized' track call.
     * Validates that clients sanitize property names that contain invalid identifier characters.
     *
     * @param PropertySanitized props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    propertySanitized,
    /**
     * Fires a 'Simple Array Types' track call.
     * Validates that clients support fields with various types of arrays.
     *
     * @param SimpleArrayTypes props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    simpleArrayTypes,
    /**
     * Fires a 'Union Type' track call.
     * Validates that clients support fields with multiple (union) types.
     *
     * @param UnionType props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    unionType,
    /**
     * Fires a 'event_collided' track call.
     * Validates that a generated client handles even naming collisions.
     *
     * @param PurpleEventCollided props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    purpleEventCollided,
    /**
     * Fires a 'NoID type' track call.
     * Properties without IDs
     *
     * @param NoIDType props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    noIDType,
};
exports.default = new Proxy(clientAPI, {
    get(target, method) {
        if (typeof method === 'string' && target.hasOwnProperty(method)) {
            return target[method];
        }
        return () => {
            console.warn(`⚠️  You made an analytics call (${String(method)}) that can't be found. Either:
         a) Re-generate your typewriter client: \`npx typewriter\`
         b) Add it to your Tracking Plan: https://app.segment.com/segment-oscb/protocols/tracking-plans/rs_1zTHJU9fd5mt7cndWnd4PgJbMCE`);
            const a = analytics();
            if (a) {
                a.track(withTypewriterContext({
                    event: 'Unknown Analytics Call Fired',
                    properties: {
                        method,
                    },
                    userId: 'typewriter',
                }));
            }
        };
    },
});
