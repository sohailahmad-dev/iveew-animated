"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.saveGlobalToken = exports.getGlobalToken = exports.getScriptToken = exports.getInputToken = exports.getToken = exports.tokenMethodToUserString = exports.TokenMethod = exports.verifyDirectoryExists = exports.resolveRelativePath = exports.saveWorkspaceConfig = exports.getWorkspaceConfig = exports.CONFIG_NAME = void 0;
const tslib_1 = require("tslib");
const fs_1 = tslib_1.__importDefault(require("fs"));
const util_1 = require("util");
const path_1 = require("path");
const yaml_1 = require("yaml");
const os_1 = require("os");
const schema_1 = require("./schema");
const api_1 = require("../api");
const common_1 = require("../common");
const scripts_1 = require("./scripts");
const errors_1 = require("@oclif/core/lib/errors");
const debug_1 = require("debug");
const debug = (0, debug_1.debug)("typewriter:config");
const readFile = (0, util_1.promisify)(fs_1.default.readFile);
const writeFile = (0, util_1.promisify)(fs_1.default.writeFile);
const exists = (0, util_1.promisify)(fs_1.default.exists);
const mkdir = (0, util_1.promisify)(fs_1.default.mkdir);
exports.CONFIG_NAME = "typewriter.yml";
/**
 * getWorkspaceConfig looks for, and reads, a typewriter.yml configuration file.
 * If it does not exist, it will return undefined. If the configuration
 * if invalid, an Error will be thrown.
 * Note: path is relative to the directory where the typewriter command
 * was run.
 * @param path
 * @returns
 */
async function getWorkspaceConfig(path) {
    // Check if a typewriter.yml exists.
    const configPath = await getPath(path);
    if (!(await exists(configPath))) {
        debug("getWorkspaceConfig", "No config file found at", configPath);
        return undefined;
    }
    // If so, read it's contents.
    let file;
    try {
        file = await readFile(configPath, {
            encoding: "utf-8",
        });
    }
    catch (error) {
        throw (0, common_1.wrapError)("Unable to open typewriter.yml", error, `Failed due to an ${error.code} error (${error.errno}).`, configPath);
    }
    const rawConfig = (0, yaml_1.parse)(file);
    debug("Loaded raw config", rawConfig);
    return (0, schema_1.validateConfig)(rawConfig);
}
exports.getWorkspaceConfig = getWorkspaceConfig;
/**
 * saveConfig writes a config out to a typewriter.yml file.
 * Note path is relative to the directory where the typewriter command
 * was run.
 * @param config
 * @param path
 */
async function saveWorkspaceConfig(config, path) {
    const CONFIG_HEADER = "Segment Typewriter Configuration (https://segment.com/docs/protocols/typewriter)\nJust run `npx typewriter@next` to re-generate a client with the latest versions of these events.";
    const doc = new yaml_1.Document(config);
    doc.commentBefore = CONFIG_HEADER;
    // Add comment to client node
    const clientNode = doc.get("client");
    clientNode.commentBefore =
        "You can find more documentation on configuring this client in the Segment docs\nSee: https://segment.com/docs/protocols/typewriter";
    // Add comment to each tracking plan
    const trackingPlans = doc.get("trackingPlans");
    for (const plan of trackingPlans.items) {
        const id = plan.get("id")?.toString();
        // We only pass in the name to fill the comment template, we don't need it in the config file anymore after retrieving the value
        const name = plan.get("name")?.toString();
        plan.delete("name");
        plan.commentBefore = `Tracking Plan: ${name}\nhttps://api.segmentapis.com/tracking-plans/${id}`;
    }
    const file = doc.toString();
    await writeFile(await getPath(path), file);
}
exports.saveWorkspaceConfig = saveWorkspaceConfig;
/**
 * resolveRelativePath resolves a relative path from the directory of the `typewriter.yml` config
 * file. It supports file and directory paths.
 * @param configPath
 * @param path
 * @param otherPaths
 * @returns
 */
function resolveRelativePath(configPath, path, ...otherPaths) {
    // Resolve the path based on the optional --config flag.
    return configPath
        ? (0, path_1.resolve)(configPath.replace(/typewriter\.yml$/, ""), path, ...otherPaths)
        : (0, path_1.resolve)(path, ...otherPaths);
}
exports.resolveRelativePath = resolveRelativePath;
async function verifyDirectoryExists(path, type = "directory") {
    // If this is a file, we need to verify it's parent directory exists.
    // If it is a directory, then we need to verify the directory itself exists.
    const dirPath = type === "directory" ? path : (0, path_1.dirname)(path);
    if (!(await exists(dirPath))) {
        await mkdir(dirPath, {
            recursive: true,
        });
    }
}
exports.verifyDirectoryExists = verifyDirectoryExists;
var TokenMethod;
(function (TokenMethod) {
    TokenMethod["Script"] = "script";
    TokenMethod["File"] = "file";
    TokenMethod["Pipe"] = "pipe";
})(TokenMethod = exports.TokenMethod || (exports.TokenMethod = {}));
function tokenMethodToUserString(method, configPath) {
    if (method === TokenMethod.Pipe) {
        return "input";
    }
    if (method === TokenMethod.Script) {
        return `${configPath ?? "."}/${exports.CONFIG_NAME}`;
    }
    return "~/.typewriter";
}
exports.tokenMethodToUserString = tokenMethodToUserString;
/**
 * getToken uses a Config to fetch a Segment API token. It will search for it in this order:
 *   1. The stdout from executing the optional token script from the config.
 *   2. cat ~/.typewriter
 * Returns undefined if no token can be found
 * @param config
 * @param configPath
 * @returns
 */
async function getToken(config, configPath, input) {
    const tokenFns = [
        () => getInputToken(input),
        () => getScriptToken(config, configPath),
        () => getGlobalToken(),
    ];
    for (const tokenFn of tokenFns) {
        const metadata = await tokenFn();
        debug("getToken", metadata);
        if (metadata.isValid === true) {
            debug("Selecting Token", metadata);
            return metadata;
        }
    }
    return undefined;
}
exports.getToken = getToken;
/**
 * Formats a token received through input
 * @param input
 * @returns
 */
async function getInputToken(input, validate = true) {
    if (input !== undefined && input.trim() !== "") {
        const token = input.trim();
        const validationResult = validate ? await (0, api_1.validateToken)(token) : undefined;
        return {
            token,
            method: TokenMethod.Pipe,
            ...validationResult,
        };
    }
    return {
        method: TokenMethod.Pipe,
    };
}
exports.getInputToken = getInputToken;
/**
 * Finds if the current workspace has a script to generate a token and retrieves the value.
 * @param config
 * @param configPath
 * @returns
 */
async function getScriptToken(config, configPath, validate = true) {
    if (config?.scripts?.token === undefined) {
        return {
            method: TokenMethod.Script,
        };
    }
    // Attempt to read a token by executing the token script from the typewriter.yml config file.
    // Handle token script errors gracefully, f.e., in CI where you don't need it.
    // TODO: Warn that scripts will be deprecated
    const tokenScript = config.scripts.token;
    const stdout = await (0, scripts_1.runScript)(tokenScript, configPath, scripts_1.Scripts.Token);
    if (stdout === undefined || stdout.trim() === "") {
        throw new errors_1.CLIError("No token was found in the stdout of the token script.", {
            suggestions: [
                `Make sure the script ${tokenScript} outputs a token to stdout.`,
                `Check your token script at ${configPath}`,
            ],
        });
    }
    const token = stdout.trim();
    const validationResult = validate ? await (0, api_1.validateToken)(token) : undefined;
    return {
        method: TokenMethod.Script,
        token,
        ...validationResult,
    };
}
exports.getScriptToken = getScriptToken;
/**
 * Retrieves the token stored in the user file: ~/.typewriter.
 * @param config
 * @param configPath
 * @returns
 */
async function getGlobalToken(validate = true) {
    // Attempt to read a token from the ~/.typewriter token file.
    // Tokens are stored here during the `init` flow, if a user generates a token.
    try {
        const path = (0, path_1.resolve)((0, os_1.homedir)(), ".typewriter");
        const token = (await readFile(path, "utf-8")).trim();
        const validationResult = validate ? await (0, api_1.validateToken)(token) : undefined;
        return {
            method: TokenMethod.File,
            token,
            ...validationResult,
        };
    }
    catch (error) {
        // Ignore errors if ~/.typewriter doesn't exist
    }
    return {
        method: TokenMethod.File,
    };
}
exports.getGlobalToken = getGlobalToken;
/**
 * storeToken writes a token to ~/.typewriter.
 * @param token
 * @returns
 */
async function saveGlobalToken(token) {
    const path = (0, path_1.resolve)((0, os_1.homedir)(), ".typewriter");
    return writeFile(path, token, "utf-8");
}
exports.saveGlobalToken = saveGlobalToken;
async function getPath(path) {
    path = path.replace(/typewriter\.yml$/, "");
    // TODO: recursively move back folders until you find it, ala package.json
    return (0, path_1.resolve)(path, exports.CONFIG_NAME);
}
